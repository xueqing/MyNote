# Base16、Base32 和 Base64 数据编码

- [Base16、Base32 和 Base64 数据编码](#base16base32-和-base64-数据编码)
  - [摘要](#摘要)
  - [1. 介绍](#1-介绍)
  - [2. 本文使用的惯例](#2-本文使用的惯例)
  - [3. 实现差异](#3-实现差异)
    - [3.1. 编码数据中的换行](#31-编码数据中的换行)
    - [3.2. 编码数据的填充](#32-编码数据的填充)
    - [3.3. 编码数据中非字母字符的解释](#33-编码数据中非字母字符的解释)
    - [3.4. 选择字母表](#34-选择字母表)
    - [3.5. 规范编码](#35-规范编码)
  - [4. base 64 编码](#4-base-64-编码)
  - [5. 带有 URL 和文件名安全字母表的 Base 64 编码](#5-带有-url-和文件名安全字母表的-base-64-编码)
  - [6. Base 32 编码](#6-base-32-编码)
  - [7. 带扩展十六进制字母表的 Base 32 编码](#7-带扩展十六进制字母表的-base-32-编码)
  - [8. Base 16 编码](#8-base-16-编码)
  - [9. 图解和示例](#9-图解和示例)
  - [10. 测试向量](#10-测试向量)
  - [11. Base64的 ISO C99 实现](#11-base64的-iso-c99-实现)
  - [12. 安全考虑](#12-安全考虑)
  - [13. 自 RFC 3548 以来的变化](#13-自-rfc-3548-以来的变化)
  - [14. 致谢](#14-致谢)
  - [15. 复制条件](#15-复制条件)
  - [16. 参考](#16-参考)
    - [16.1. 规范性引用文件](#161-规范性引用文件)
    - [16.2. 资料性引用](#162-资料性引用)
  - [作者地址](#作者地址)

## 摘要

本文介绍了常用的 base 64、base 32 和 base 16 编码方案。它还讨论了在编码数据中使用换行、在编码数据中使用填充、在编码数据中使用非字母字符、使用不同的编码字母以及规范编码。

## 1. 介绍

在许多情况下，使用数据的基本编码存储或传输环境中的数据，这些环境可能出于遗留原因，仅限于 US-ASCII [^1] 数据。没有遗留限制的新应用程序也可以使用基本编码，仅仅是因为这样可以使用文本编辑器操纵对象。

在过去，不同应用程序有不同的需求，因此有时以稍微不同的方式实现基本编码。今天，协议规范有时通常使用基本编码，特别是 `base64` ，而没有精确的描述或引用。多用途 Internet 邮件扩展(MIME) [^4] 通常用作 base64 的参考，而未考虑换行或非字母字符的后果。本规范旨在确定通用字母表和编码注意事项。这有望减少其他文档中的歧义，从而实现更好的互操作性。

## 2. 本文使用的惯例

本文中的关键词“必须”、“不能”、“要求”、“应”、“不应”、“建议”、“可”和“可选”应按照 [^2] 中所述进行解释。

## 3. 实现差异

在这里，我们讨论过去的基本编码实现之间的差异，并在适当的情况下，为未来指定特定的推荐行为。

### 3.1. 编码数据中的换行

MIME [^4] 通常用作 base 64 编码的参考。然而，MIME 本身并没有定义 “base 64”，而是定义了一种在 MIME 中使用的 “base64 内容传输编码”。同样地，MIME 将 base 64 编码数据的行长度限制为 76 个字符。MIME 继承了隐私增强邮件(PEM) [^3] 的编码，声明它“几乎相同”；但是，PEM 使用 64 个字符的行长度。MIME 和 PEM 限制都是由于 SMTP 中的限制造成的。

除非引用本文档的规范明确指示基本编码器在特定数量的字符后添加换行符，否则实现**不能**向基本编码数据添加换行符。

### 3.2. 编码数据的填充

在某些情况下，基本编码数据中不需要或不使用填充(`=`)。一般情况下，当无法对传输数据的大小进行假设时，需要填充以产生正确的解码数据。

实现**必须**在编码数据的末尾包含适当的填充字符，除非引用本文档的规范明确规定了其他内容。

base64 和 base32 字母表使用填充，如下文第 4 节和第 6 节所述，但 base16 字母表不需要填充；见第 8 节。

### 3.3. 编码数据中非字母字符的解释

基本编码使用特定的简化字母表来编码二进制数据。由于数据损坏或设计原因，基本编码数据中可能存在非字母字符。可能利用非字母字符作为“隐蔽通道”，其中可能用于恶意发送非协议数据。还可能发送非字母字符，以利用实现错误导致缓冲区溢出攻击等。

在解释基本编码数据时，如果编码数据包含基本字母表之外的字符，则实现**必须**拒绝该编码数据，除非引用本文档的规范明确规定了其他内容。这些规范可能会像 MIME 那样声明，在解释数据时，应该忽略基本编码字母表之外的字符(“接受是自由的”)。请注意，这意味着任何相邻的回车/换行(CRLF, carriage return/
line feed)字符构成“非字母字符”，将被忽略。此外，如果填充字符 `=` 出现在编码数据的末尾之前，则此类规范**可以**忽略该填充字符，将其视为非字母数据。如果在字符串末尾发现超过允许数量的填充字符(例如，以 `===` 结尾的 base 64 字符串)，也**可以**忽略多余的填充字符。

### 3.4. 选择字母表

不同的应用程序对字母表中的字符有不同的要求。以下一些要求确定应使用哪个字母表：

- 由人类操纵。字符 `0` 和 `O` 很容易混淆， `1`、`l` 和 `I` 也很容易混淆。在下面的 base32 字母表中，如果 0 (零)和 1 (一)不存在，解码器可能会根据情况将 0 解释为 O，将 1 解释为 I 或 L。(但是，默认情况下不应如此；请参见上一节。)
- 编码到强制其他需求的结构中。对于 base 16 和 base 32，这决定了使用大写或小写字母。对于 base 64，文件名和 URL 中的非字母数字字符(尤其是 `/`)可能有问题。
- 用作标识符。某些字符，尤其是 base 64 字母表中的 `+` 和 `/`，传统的文本搜索/索引工具将其视为词内换行。

没有一种普遍接受的字母表能够满足所有的要求。有关高度专业化变体的示例，请参见 IMAP [^8]。在本文中，我们记录并命名了一些当前使用的字母表。

### 3.5. 规范编码

如果实现不当，则 base 64 和 base 32 编码中的填充步骤可能会导致编码数据的非重大更改。例如，如果 base 64 编码的输入仅为一个八位字节，则使用第一个符号的所有六位，但仅使用下一个符号的前两位。这些填充位**必须**通过一致的编码器设置为零，下面的填充说明对此进行了描述。如果此属性不成立，则不存在基本编码数据的规范表示，并且可以将多个基本编码字符串解码为相同的二进制数据。如果此属性(以及本文档中讨论的其他属性)成立，则确保规范编码。

在某些环境中，更改是至关重要的，因此，如果填充位未设置为零，解码器**可以**会选择拒绝编码。引用此规范的规范可能要求特定的行为。

## 4. base 64 编码

以下对 base 64 的描述源自 [^3]、[^4]、[^5] 和 [^6]。这种编码可以称为 `base64`。

Base 64 编码设计用于表示任意八位字节序列，其表示形式允许使用大写和小写字母但不需要人类可读。

使用 US-ASCII 的 65 个字符子集，使每个可打印字符能够表示 6 位。(额外的第 65 个字符 `=` 用于表示特殊处理功能。)

编码过程将 24 位输入位组表示为 4 个编码字符的输出字符串。从左到右，通过连接 3 个 8 位输入组形成 24 位输入组。然后将这 24 位视为 4 个连接的 6 位组，将每个组转换为 base 64 字母表中的单个字符。

每个 6 位组用作 64 个可打印字符数组的索引。将索引引用的字符放置在输出字符串。

表 1：base 64 字母表

```txt
Value Encoding  Value Encoding  Value Encoding  Value Encoding
    0 A            17 R            34 i            51 z
    1 B            18 S            35 j            52 0
    2 C            19 T            36 k            53 1
    3 D            20 U            37 l            54 2
    4 E            21 V            38 m            55 3
    5 F            22 W            39 n            56 4
    6 G            23 X            40 o            57 5
    7 H            24 Y            41 p            58 6
    8 I            25 Z            42 q            59 7
    9 J            26 a            43 r            60 8
   10 K            27 b            44 s            61 9
   11 L            28 c            45 t            62 +
   12 M            29 d            46 u            63 /
   13 N            30 e            47 v
   14 O            31 f            48 w         (pad) =
   15 P            32 g            49 x
   16 Q            33 h            50 y
```

如果编码数据末尾可用位少于 24 位，则执行特殊处理。一个完整的编码量总是在一个量的末尾完成。当一个输入组中可用输入位少于 24 位时，(在右侧)添加零值的位以形成整数个 6 位组。数据末尾的填充使用 `=` 字符实现。由于所有 base 64 输入都是八位字节的整数，因此只能出现以下情况：

1) 编码输入最后的量是 24 位的整数倍；这里，编码输出最后的单位将是 4 个字符的整数倍，没有 `=` 填充。
2) 编码输入最后的量正好是 8 位；这里，编码输出最后的单位是 2 个字符，后跟两个 `=` 填充字符。
3) 编码输入最后的量正好是 16 位；这里，编码输出最后的单位是 3 个字符，后跟一个 `=` 填充字符。

## 5. 带有 URL 和文件名安全字母表的 Base 64 编码

[^12] 中使用了带有 URL 和文件名安全字母表的 Base 64 编码。

有人建议另一种使用 `~` 作为第 63 个字符的字母表。由于 `~` 字符在某些文件系统环境中具有特殊意义，因此建议改用本节描述的编码。剩余的未保留 URI 字符是 `.`，但某些文件系统环境不允许文件名中有多个 `.`，因此 `.` 字符也不具有吸引力。

在 URI [^9] 中使用填充字符 `=` 时通常采用百分比编码，但如果数据长度是隐式已知的，则可以通过跳过填充来避免这种情况；见第 3.2 节。

此编码可称为 `base64url`。不应将此编码视为与 `base64` 编码相同，也不应仅称为 `base64`。除非另有说明，`base64` 指上一节中的 base 64。

除表 2 中所示的字母表第 62 和 63 个字符外，此编码在技术上与前一种编码相同。

表 2：“URL 和文件名安全” Base 64 字母表

```txt
Value Encoding  Value Encoding  Value Encoding  Value Encoding
    0 A            17 R            34 i            51 z
    1 B            18 S            35 j            52 0
    2 C            19 T            36 k            53 1
    3 D            20 U            37 l            54 2
    4 E            21 V            38 m            55 3
    5 F            22 W            39 n            56 4
    6 G            23 X            40 o            57 5
    7 H            24 Y            41 p            58 6
    8 I            25 Z            42 q            59 7
    9 J            26 a            43 r            60 8
   10 K            27 b            44 s            61 9
   11 L            28 c            45 t            62 - (minus)
   12 M            29 d            46 u            63 _
   13 N            30 e            47 v            (underline)
   14 O            31 f            48 w
   15 P            32 g            49 x
   16 Q            33 h            50 y         (pad) =
```

## 6. Base 32 编码

以下对 base 32 的描述源自 [^11](带更正)。这种编码可以称为 `base32`。

Base 32 编码设计用于表示任意八位字节序列，其表示形式不区分大小写但不需要人类可读。

使用 US-ASCII 的 33 个字符子集，使每个可打印字符能够表示 5 位。(额外的第 33 个字符 `=` 用于表示特殊处理功能。)

编码过程将 40 位输入位组表示为 8 个编码字符的输出字符串。从左到右，通过连接 5 个 8 位输入组形成 40 位输入组。然后将这 40 位视为 8 个连接的 5 位组，将每个组转换为 base 32 字母表中的单个字符。当通过 base 32 编码对比特流进行编码时，必须假定比特流以最高有效位优先排序。也就是说，流中的第一位将是第一个 8 位字节的高位，第八位将是第一个 8 位字节的低位，依此类推。

每个 5 位组用作 32 个可打印字符数组的索引。将索引引用的字符放置在输出字符串。下表 3 中标识的这些字符选自 US-ASCII 的数字和大写字母。

表 3：Base 32 字母表

```txt
Value Encoding  Value Encoding  Value Encoding  Value Encoding
    0 A             9 J            18 S            27 3
    1 B            10 K            19 T            28 4
    2 C            11 L            20 U            29 5
    3 D            12 M            21 V            30 6
    4 E            13 N            22 W            31 7
    5 F            14 O            23 X
    6 G            15 P            24 Y         (pad) =
    7 H            16 Q            25 Z
    8 I            17 R            26 2
```

如果编码数据末尾可用位少于 40 位，则执行特殊处理。一个完整的编码量总是在主体的末尾完成。当一个输入组中可用输入位少于 40 位时，(在右侧)添加零值的位以形成整数个 5 位组。数据末尾的填充使用 `=` 字符实现。由于所有 base 32 输入都是八位字节的整数，因此只能出现以下情况：

1) 编码输入最后的量是 40 位的整数倍；这里，编码输出最后的单位将是 8 个字符的整数倍，没有 `=` 填充。
2) 编码输入最后的量正好是 8 位；这里，编码输出最后的单位是 2 个字符，后跟六个 `=` 填充字符。
3) 编码输入最后的量正好是 16 位；这里，编码输出最后的单位是 4 个字符，后跟四个 `=` 填充字符。
4) 编码输入最后的量正好是 24 位；这里，编码输出最后的单位是 5 个字符，后跟三个 `=` 填充字符。
5) 编码输入最后的量正好是 32 位；这里，编码输出最后的单位是 7 个字符，后跟一个 `=` 填充字符。

## 7. 带扩展十六进制字母表的 Base 32 编码

以下对 base 32的描述源自 [^7]。这种编码可以称为 `base32hex`。不应将此编码视为与 `base32` 编码相同，也不应仅称为 `base32`。例如，NextSECure3(NSEC3) [^10] 使用这种编码。

此字母表的一个属性是，当按位比较编码数据时，编码数据保持其排序，也是 base64 和 base32 字母表缺少的一个属性。

除字母表外，此编码与前一种编码相同。新字母表见表 4。

表 4：“扩展十六进制” Base 32 字母表

```txt
Value Encoding Value Encoding Value Encoding Value Encoding
    0 0            9 9           18 I           27 R
    1 1           10 A           19 J           28 S
    2 2           11 B           20 K           29 T
    3 3           12 C           21 L           30 U
    4 4           13 D           22 M           31 V
    5 5           14 E           23 N
    6 6           15 F           24 O        (pad) =
    7 7           16 G           25 P
    8 8           17 H           26 Q
```

## 8. Base 16 编码

以下描述为原始描述，但与之前的描述类似。基本上，Base 16 编码是标准的不区分大小写的十六进制编码，可以称为 `base16` 或 `hex`。

使用 US-ASCII 的 16 个字符子集，使每个可打印字符能够表示 4 位。

编码过程将 8 位输入位组(八位字节)表示为 2 个编码字符的输出字符串。从左到右，从输入数据中获取 8 位输入。然后，将这 8 位视为 2 个连接的 4 位组，将每个组转换成 base 16 字母表中的单个字符。

每个 4 位组用作 16 个可打印字符数组的索引。将索引引用的字符放置在输出字符串。

表 5：Base 16 字母表

```txt
Value Encoding Value Encoding Value Encoding Value Encoding
    0 0            4 4            8 8           12 C
    1 1            5 5            9 9           13 D
    2 2            6 6           10 A           14 E
    3 3            7 7           11 B           15 F
```

与 base 32 和 base 64 不同，由于完整的码字始终可用，因此不需要特殊的填充。

## 9. 图解和示例

为了在二进制编码和基本编码之间进行转换，将输入存储在一个结构中，然后提取输出。下图显示了 base 64 的情况，借用自 [^5]。

```txt
+--first octet--+-second octet--+--third octet--+
|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|
+-----------+---+-------+-------+---+-----------+
|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|
+--1.index--+--2.index--+--3.index--+--4.index--+
```

下图显示了 base 32 的情况，借用自 [^7]。base-32 值中的每个连续字符表示底层八位字节序列的 5 个连续位。因此，每个 8 字符组代表 5 个八位字节(40 位)的序列。

```txt
   1          2          3
 01234567 89012345 67890123 45678901 23456789
+--------+--------+--------+--------+--------+
|< 1 >< 2| >< 3 ><|.4 >< 5.|>< 6 ><.|7 >< 8 >|
+--------+--------+--------+--------+--------+
                                        <===> 8th character
                                  <====> 7th character
                             <===> 6th character
                       <====> 5th character
                 <====> 4th character
            <===> 3rd character
      <====> 2nd character
<===> 1st character    
```

下面的 Base64 数据示例来自 [^5] ，并进行了更正。

```txt
Input data: 0x14fb9c03d97e
Hex:     1   4    f   b    9   c     | 0   3    d   9    7   e
8-bit:   00010100 11111011 10011100  | 00000011 11011001 01111110
6-bit:   000101 001111 101110 011100 | 000000 111101 100101 111110
Decimal: 5      15     46     28       0      61     37     62
Output:  F      P      u      c        A      9      l      +

Input data: 0x14fb9c03d9
Hex:     1   4    f   b    9   c     | 0   3    d   9
8-bit:   00010100 11111011 10011100  | 00000011 11011001
                                                pad with 00
6-bit:   000101 001111 101110 011100 | 000000 111101 100100
Decimal: 5      15     46     28       0      61     36
                                                   pad with =
Output:  F      P      u      c        A      9      k      =

Input data: 0x14fb9c03
Hex:     1   4    f   b    9   c     | 0   3
8-bit:   00010100 11111011 10011100  | 00000011
                                       pad with 0000
6-bit:   000101 001111 101110 011100 | 000000 110000
Decimal: 5      15     46     28       0      48
                                            pad with =      =
Output:  F      P      u      c        A      w      =      =
```

## 10. 测试向量

BASE64("") = ""
BASE64("f") = "Zg=="
BASE64("fo") = "Zm8="
BASE64("foo") = "Zm9v"
BASE64("foob") = "Zm9vYg=="
BASE64("fooba") = "Zm9vYmE="
BASE64("foobar") = "Zm9vYmFy"

BASE32("") = ""
BASE32("f") = "MY======"
BASE32("fo") = "MZXQ===="
BASE32("foo") = "MZXW6==="
BASE32("foob") = "MZXW6YQ="
BASE32("fooba") = "MZXW6YTB"
BASE32("foobar") = "MZXW6YTBOI======"

BASE32-HEX("") = ""
BASE32-HEX("f") = "CO======"
BASE32-HEX("fo") = "CPNG===="
BASE32-HEX("foo") = "CPNMU==="
BASE32-HEX("foob") = "CPNMUOG="
BASE32-HEX("fooba") = "CPNMUOJ1"
BASE32-HEX("foobar") = "CPNMUOJ1E8======"

BASE16("") = ""
BASE16("f") = "66"
BASE16("fo") = "666F"
BASE16("foo") = "666F6F"
BASE16("foob") = "666F6F62"
BASE16("fooba") = "666F6F6261"
BASE16("foobar") = "666F6F626172"

## 11. Base64的 ISO C99 实现

An ISO C99 implementation of Base64 encoding and decoding that is believed to follow all recommendations in this RFC is available from:

Base64 编码和解码的一个 ISO C99 实现被认为遵循本 RFC 中的所有建议，可从以下网站获得：

   <http://josefsson.org/base-encoding/>

此代码不规范。

由于程序原因，该代码无法包含在本 RFC 中(RFC 3978 第 5.4 节)。

## 12. 安全考虑

在实现基本编码和解码时，应注意不要给实现带来缓冲区溢出攻击或其他攻击的漏洞。解码器不应在无效输入时中断，例如，包括嵌入的 NUL 字符(ASCII 0)。

如果忽略非字母字符，而不是导致整个编码被拒绝(如建议的那样)，则可以使用可用于“泄漏”信息的隐蔽通道。被忽略的字符还可用于其他恶意目的，如避免字符串相等比较或触发实现错误。在不遵循推荐做法的应用程序中，应理解忽略非字母字符的含义。类似地，当以不区分大小写的方式处理 base 16 和 base 32 字母表时，大小写的更改可用于泄漏信息或使字符串相等性比较失败。

当使用填充时，有一些非重要位需要考虑安全问题，因为它们可能被滥用以泄漏信息或用于绕过字符串相等性比较或触发实现问题。

基本编码直观地隐藏了其他容易识别的信息，如密码，但不提供任何计算机密性。众所周知，当用户报告网络协议交换的详细信息(可能是为了说明某些其他问题)并意外泄露密码时，这会导致安全事件，因为她不知道基本编码不保护密码。

基本编码不会给明文增加熵，但它确实增加了可用明文的数量，并以特征概率分布的形式为密码分析提供签名。

## 13. 自 RFC 3548 以来的变化

添加了“base32 扩展十六进制字母表”，需要保留编码数据的排序。

此处使用的特殊 Base64 编码的参考 IMAP。

修复了从 RFC2440 复制的示例。

增加了关于为密码分析提供签名的安全考虑。

添加了测试向量。

修正了拼写错误。

## 14. 致谢

一些人提出了意见和/或建议，包括约翰·E·哈德斯塔特、托尼·汉森、戈登·莫尔、约翰·迈尔斯、克里斯·纽曼和安德鲁·西伯。本文中使用的文本基于早期 RFC，描述了各种基本编码的具体用途。作者感谢 RSA 实验室支持本文档的工作。

本修订版本部分基于罗伊·阿伦兹、埃里克·布莱克、布莱恩·卡彭特、埃尔温·戴维斯、比尔·芬纳、萨姆·哈特曼、泰德·哈迪、佩尔·海根、杰尔特·詹森、克莱门特·肯特、泰罗·基维宁、保罗·奎特考斯基和本·劳里提出的意见和/或建议。

## 15. 复制条件

版权所有(c)2000-2006 Simon Josefsson

关于 Simon Josefsson(“作者”，本节剩余部分)撰写的摘要以及本文第 1、3、8、10、12、13 和 14 节，作者不作任何保证，也不对因使用本摘要而造成的任何损害负责。作者向任何人授予不可撤销的许可，允许其以任何方式使用、修改和分发本文，但不得削弱任何其他人使用、修改和分发本文的权利，前提是重新分发的衍生作品不包含误导性作者或版本信息，也不得虚假地声称为 IETF RFC 文件。衍生作品无需根据类似条款获得许可。

## 16. 参考

### 16.1. 规范性引用文件

[^1]  Cerf, V., "ASCII format for network interchange", RFC 20, October 1969.
[^2]  Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.

### 16.2. 资料性引用

[^3]  Linn, J., "Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures", RFC 1421, February 1993.
[^4]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies", RFC 2045, November 1996.
[^5]  Callas, J., Donnerhacke, L., Finney, H., and R. Thayer, "OpenPGP Message Format", RFC 2440, November 1998.
[^6]  Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, "DNS Security Introduction and Requirements", RFC 4033, March 2005.
[^7]  Klyne, G. and L. Masinter, "Identifying Composite Media Features", RFC 2938, September 2000.
[^8]  Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1", RFC 3501, March 2003.
[^9]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986, January 2005.
[10] Laurie, B., Sisson, G., Arends, R., and D. Blacka, "DNSSEC Hash Authenticated Denial of Existence", Work in Progress, June 2006.
[11] Myers, J., "SASL GSSAPI mechanisms", Work in Progress, May 2000.
[12] Wilcox-O'Hearn, B., "Post to P2P-hackers mailing list", <http://zgp.org/pipermail/p2p-hackers/2001-September/000315.html>, September 2001.

## 作者地址

Simon Josefsson SJD 电子邮件：simon@josefsson.org
