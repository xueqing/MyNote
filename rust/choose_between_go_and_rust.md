# 开发者的困境：在 Go 和 Rust 之间选择

- [开发者的困境：在 Go 和 Rust 之间选择](#开发者的困境在-go-和-rust-之间选择)
  - [Go 编程语言](#go-编程语言)
  - [Rust 编程语言](#rust-编程语言)
  - [Go 和 Rust 的相似性](#go-和-rust-的相似性)
  - [Go vs. Rust](#go-vs-rust)

[原文](https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/)。

如果列出过去十年中出现的重要编程语言，[Go](https://golang.org/) 和 [Rust](https://www.rust-lang.org/) 几乎肯定会出现在其中。

同样，如果你坐下来思考当今哪种编程语言最适合开发安全的、对微服务又好的框架或应用程序，你可能会发现自己在 Go 和 Rust 之间争论不休。

如果你正在努力决定 Go 还是 Rust 是更适合你的开发需求的语言，请继续阅读。这篇文章比较了 Go 和 Rust，解释了它们的相似之处、不同之处以及它们各自可以为你做什么。

## Go 编程语言

Go(也称为 Golang) 于 2009 年向公众推出，又谷歌工程师(包括 Unix 注明的 Ken Thompson)设计。Go 的创建背后有各种动机，但开发人员的目标也许可以简单概括为他们想要的一种语言，这种语言提供 C++ 的效率，但更易于编写、阅读，并且以优化的方式部署在多核 CPU 上。

为此，Go 的一个显著特性是 goroutine，它使得可以轻松定义函数作为不同子进程运行。通过利用 goroutine，开发者可以轻松地在 Go 中构建应用程序，通过同时跨跨多个 CPU 核部署工作负载来充分利用并发性。

并发性和优化是最强大的特性。它们是我们选择使用 Go 开发 Twistlock 的部分原因。

## Rust 编程语言

Rust 的历史在很多方面与 Go 相似。Rust 诞生于 2000 年代中期开始的 Mozilla 工程师的个人项目。该语言在 2010 年公开可用。

与 Go 一样，Rust 的部分动机是希望改进 C++ 的约定，包括使其更易实现并发。以不损害安全性的方式这样做也是主要考虑。为此，Rust 使开发者很难在代码中引入可能导致缓冲区溢出或其他内存相关漏洞的缺陷。

## Go 和 Rust 的相似性

在很多方面，Go 和 Rust 是相似的。它们都是当今广泛使用的最年轻的编程语言之一。(当今大多数流行语言，像 C、Java 和 Python 都相当古老。)

Go 和 Rust 都是编译语言，都是开源的，而且都是为现代的、面向微服务的并行计算环境设计的。

如果你已经了解 C++，它们都很容易学习。

## Go vs. Rust

这可能让你想知道，“我应该使用 Go 还是 Rust 来开发下个应用程序？”

有很多方法可以回答这个问题，但是我建议根据你正在构建的应用程序的类型来考虑。在我看来，Go 迎合了更广泛的用例集，并且更加灵活。Go 可以很容易地构建一个精心分解的应用程序，该程序在部署为一组微服务的同时充分利用了并发性。

Rust 也可以做这些事情，但可以说它更难一些。在某些方面，Rust 痴迷于防止与内存相关的安全漏洞，这意味着程序员必须不遗余力地执行其他语言(包括 Go)中更简单的任务。

请注意，顺便说一下，这并非意味着 Go 不安全。Go 与任何其他现代编程语言一样安全。它只是不像 Rust 那样关注安全性，或者允许安全性优先于更广泛的功能。

简而言之：Rust 更难适应，并且更倾向于构建范围狭窄的应用程序，其中安全性是唯一真正重要的事情。相比之下，Go 非常适合构建不仅关注安全性，而且关注各种其他因素的应用程序——如果你是一个旨在构建灵活、可扩展的应用程序或框架的 DevOps 团队，这可能是你的目标。

同样值得注意的是，Go 在当今的开发者中更为流行。[TIOBE 指数](https://www.tiobe.com/tiobe-index/)最受欢迎的编程语言中，Go 排在第 15 位，而 Rust 排在第 34 位。我知道你妈妈告诉过你，你不应该仅仅因为其他人而这样做，但在编程世界中，选择更流行的语言确实有好处。其他程序员更可能认识这些语言，这使得共享代码或团队添加成员变得更加容易。流行语言往往也有更好的社区支持、文档和插件。

如果听起来我对是否使用 Go 或 Rust 做出明确的建议犹豫不决，那是因为我确实如此。二者都是很棒的现代语言，在决定如何构建新的应用程序时，最好同时考虑两者。

也就是说，我和大多数程序员一样，倾向于更倾向 Go，一般来说，因为它迎合了更广泛的用例集，同时仍然提供了高水平的安全性和性能。
